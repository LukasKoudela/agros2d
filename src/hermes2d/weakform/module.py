#!/usr/bin/env python
# -*- coding: utf-8 -*- 

#
# Generated Tue Nov 29 14:01:04 2011 by generateDS.py version 2.7a.
#

import sys
import re as re_

etree_ = None
Verbose_import_ = False
(   XMLParser_import_none, XMLParser_import_lxml,
    XMLParser_import_elementtree
    ) = range(3)
XMLParser_import_library = None
try:
    # lxml
    from lxml import etree as etree_
    XMLParser_import_library = XMLParser_import_lxml
    if Verbose_import_:
        print("running with lxml.etree")
except ImportError:
    try:
        # cElementTree from Python 2.5+
        import xml.etree.cElementTree as etree_
        XMLParser_import_library = XMLParser_import_elementtree
        if Verbose_import_:
            print("running with cElementTree on Python 2.5+")
    except ImportError:
        try:
            # ElementTree from Python 2.5+
            import xml.etree.ElementTree as etree_
            XMLParser_import_library = XMLParser_import_elementtree
            if Verbose_import_:
                print("running with ElementTree on Python 2.5+")
        except ImportError:
            try:
                # normal cElementTree install
                import cElementTree as etree_
                XMLParser_import_library = XMLParser_import_elementtree
                if Verbose_import_:
                    print("running with cElementTree")
            except ImportError:
                try:
                    # normal ElementTree install
                    import elementtree.ElementTree as etree_
                    XMLParser_import_library = XMLParser_import_elementtree
                    if Verbose_import_:
                        print("running with ElementTree")
                except ImportError:
                    raise ImportError("Failed to import ElementTree from any known place")

def parsexml_(*args, **kwargs):
    if (XMLParser_import_library == XMLParser_import_lxml and
        'parser' not in kwargs):
        # Use the lxml ElementTree compatible parser so that, e.g.,
        #   we ignore comments.
        kwargs['parser'] = etree_.ETCompatXMLParser()
    doc = etree_.parse(*args, **kwargs)
    return doc

#
# User methods
#
# Calls to the methods in these classes are generated by generateDS.py.
# You can replace these methods by re-implementing the following class
#   in a module named generatedssuper.py.

try:
    from generatedssuper import GeneratedsSuper
except ImportError, exp:

    class GeneratedsSuper(object):
        def gds_format_string(self, input_data, input_name=''):
            return input_data
        def gds_validate_string(self, input_data, node, input_name=''):
            return input_data
        def gds_format_integer(self, input_data, input_name=''):
            return '%d' % input_data
        def gds_validate_integer(self, input_data, node, input_name=''):
            return input_data
        def gds_format_integer_list(self, input_data, input_name=''):
            return '%s' % input_data
        def gds_validate_integer_list(self, input_data, node, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    fvalue = float(value)
                except (TypeError, ValueError), exp:
                    raise_parse_error(node, 'Requires sequence of integers')
            return input_data
        def gds_format_float(self, input_data, input_name=''):
            return '%f' % input_data
        def gds_validate_float(self, input_data, node, input_name=''):
            return input_data
        def gds_format_float_list(self, input_data, input_name=''):
            return '%s' % input_data
        def gds_validate_float_list(self, input_data, node, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    fvalue = float(value)
                except (TypeError, ValueError), exp:
                    raise_parse_error(node, 'Requires sequence of floats')
            return input_data
        def gds_format_double(self, input_data, input_name=''):
            return '%e' % input_data
        def gds_validate_double(self, input_data, node, input_name=''):
            return input_data
        def gds_format_double_list(self, input_data, input_name=''):
            return '%s' % input_data
        def gds_validate_double_list(self, input_data, node, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    fvalue = float(value)
                except (TypeError, ValueError), exp:
                    raise_parse_error(node, 'Requires sequence of doubles')
            return input_data
        def gds_format_boolean(self, input_data, input_name=''):
            return '%s' % input_data
        def gds_validate_boolean(self, input_data, node, input_name=''):
            return input_data
        def gds_format_boolean_list(self, input_data, input_name=''):
            return '%s' % input_data
        def gds_validate_boolean_list(self, input_data, node, input_name=''):
            values = input_data.split()
            for value in values:
                if value not in ('true', '1', 'false', '0', ):
                    raise_parse_error(node, 'Requires sequence of booleans ("true", "1", "false", "0")')
            return input_data
        def gds_str_lower(self, instring):
            return instring.lower()
        def get_path_(self, node):
            path_list = []
            self.get_path_list_(node, path_list)
            path_list.reverse()
            path = '/'.join(path_list)
            return path
        Tag_strip_pattern_ = re_.compile(r'\{.*\}')
        def get_path_list_(self, node, path_list):
            if node is None:
                return
            tag = GeneratedsSuper.Tag_strip_pattern_.sub('', node.tag)
            if tag:
                path_list.append(tag)
            self.get_path_list_(node.getparent(), path_list)
        def get_class_obj_(self, node, default_class=None):
            class_obj1 = default_class
            if 'xsi' in node.nsmap:
                classname = node.get('{%s}type' % node.nsmap['xsi'])
                if classname is not None:
                    names = classname.split(':')
                    if len(names) == 2:
                        classname = names[1]
                    class_obj2 = globals().get(classname)
                    if class_obj2 is not None:
                        class_obj1 = class_obj2
            return class_obj1
        def gds_build_any(self, node, type_name=None):
            return None


#
# If you have installed IPython you can uncomment and use the following.
# IPython is available from http://ipython.scipy.org/.
#

## from IPython.Shell import IPShellEmbed
## args = ''
## ipshell = IPShellEmbed(args,
##     banner = 'Dropping into IPython',
##     exit_msg = 'Leaving Interpreter, back to program.')

# Then use the following line where and when you want to drop into the
# IPython shell:
#    ipshell('<some message> -- Entering ipshell.\nHit Ctrl-D to exit')

#
# Globals
#

ExternalEncoding = 'ascii'
Tag_pattern_ = re_.compile(r'({.*})?(.*)')
String_cleanup_pat_ = re_.compile(r"[\n\r\s]+")
Namespace_extract_pat_ = re_.compile(r'{(.*)}(.*)')

#
# Support/utility functions.
#

def showIndent(outfile, level):
    for idx in range(level):
        outfile.write('    ')

def quote_xml(inStr):
    if not inStr:
        return ''
    s1 = (isinstance(inStr, basestring) and inStr or
          '%s' % inStr)
    s1 = s1.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    return s1

def quote_attrib(inStr):
    s1 = (isinstance(inStr, basestring) and inStr or
          '%s' % inStr)
    s1 = s1.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    if '"' in s1:
        if "'" in s1:
            s1 = '"%s"' % s1.replace('"', "&quot;")
        else:
            s1 = "'%s'" % s1
    else:
        s1 = '"%s"' % s1
    return s1

def quote_python(inStr):
    s1 = inStr
    if s1.find("'") == -1:
        if s1.find('\n') == -1:
            return "'%s'" % s1
        else:
            return "'''%s'''" % s1
    else:
        if s1.find('"') != -1:
            s1 = s1.replace('"', '\\"')
        if s1.find('\n') == -1:
            return '"%s"' % s1
        else:
            return '"""%s"""' % s1

def get_all_text_(node):
    if node.text is not None:
        text = node.text
    else:
        text = ''
    for child in node:
        if child.tail is not None:
            text += child.tail
    return text

def find_attr_value_(attr_name, node):
    attrs = node.attrib
    attr_parts = attr_name.split(':')
    value = None
    if len(attr_parts) == 1:
        value = attrs.get(attr_name)
    elif len(attr_parts) == 2:
        prefix, name = attr_parts
        namespace = node.nsmap.get(prefix)
        if namespace is not None:
            value = attrs.get('{%s}%s' % (namespace, name, ))
    return value


class GDSParseError(Exception):
    pass

def raise_parse_error(node, msg):
    if XMLParser_import_library == XMLParser_import_lxml:
        msg = '%s (element %s/line %d)' % (msg, node.tag, node.sourceline, )
    else:
        msg = '%s (element %s)' % (msg, node.tag, )
    raise GDSParseError(msg)


class MixedContainer:
    # Constants for category:
    CategoryNone = 0
    CategoryText = 1
    CategorySimple = 2
    CategoryComplex = 3
    # Constants for content_type:
    TypeNone = 0
    TypeText = 1
    TypeString = 2
    TypeInteger = 3
    TypeFloat = 4
    TypeDecimal = 5
    TypeDouble = 6
    TypeBoolean = 7
    def __init__(self, category, content_type, name, value):
        self.category = category
        self.content_type = content_type
        self.name = name
        self.value = value
    def getCategory(self):
        return self.category
    def getContenttype(self, content_type):
        return self.content_type
    def getValue(self):
        return self.value
    def getName(self):
        return self.name
    def export(self, outfile, level, name, namespace):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip(): 
                outfile.write(self.value)
        elif self.category == MixedContainer.CategorySimple:
            self.exportSimple(outfile, level, name)
        else:    # category == MixedContainer.CategoryComplex
            self.value.export(outfile, level, namespace,name)
    def exportSimple(self, outfile, level, name):
        if self.content_type == MixedContainer.TypeString:
            outfile.write('<%s>%s</%s>' % (self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeInteger or \
                self.content_type == MixedContainer.TypeBoolean:
            outfile.write('<%s>%d</%s>' % (self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeFloat or \
                self.content_type == MixedContainer.TypeDecimal:
            outfile.write('<%s>%f</%s>' % (self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeDouble:
            outfile.write('<%s>%g</%s>' % (self.name, self.value, self.name))
    def exportLiteral(self, outfile, level, name):
        if self.category == MixedContainer.CategoryText:
            showIndent(outfile, level)
            outfile.write('model_.MixedContainer(%d, %d, "%s", "%s"),\n' % \
                (self.category, self.content_type, self.name, self.value))
        elif self.category == MixedContainer.CategorySimple:
            showIndent(outfile, level)
            outfile.write('model_.MixedContainer(%d, %d, "%s", "%s"),\n' % \
                (self.category, self.content_type, self.name, self.value))
        else:    # category == MixedContainer.CategoryComplex
            showIndent(outfile, level)
            outfile.write('model_.MixedContainer(%d, %d, "%s",\n' % \
                (self.category, self.content_type, self.name,))
            self.value.exportLiteral(outfile, level + 1)
            showIndent(outfile, level)
            outfile.write(')\n')


class MemberSpec_(object):
    def __init__(self, name='', data_type='', container=0):
        self.name = name
        self.data_type = data_type
        self.container = container
    def set_name(self, name): self.name = name
    def get_name(self): return self.name
    def set_data_type(self, data_type): self.data_type = data_type
    def get_data_type_chain(self): return self.data_type
    def get_data_type(self):
        if isinstance(self.data_type, list):
            if len(self.data_type) > 0:
                return self.data_type[-1]
            else:
                return 'xs:string'
        else:
            return self.data_type
    def set_container(self, container): self.container = container
    def get_container(self): return self.container

def _cast(typ, value):
    if typ is None or value is None:
        return value
    return typ(value)

#
# Data representation classes.
#

class module(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, general=None, constants=None, macros=None, volume=None, surface=None, preprocessor=None, postprocessor=None):
        self.general = general
        self.constants = constants
        self.macros = macros
        self.volume = volume
        self.surface = surface
        self.preprocessor = preprocessor
        self.postprocessor = postprocessor
    def factory(*args_, **kwargs_):
        if module.subclass:
            return module.subclass(*args_, **kwargs_)
        else:
            return module(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_general(self): return self.general
    def set_general(self, general): self.general = general
    def get_constants(self): return self.constants
    def set_constants(self, constants): self.constants = constants
    def get_macros(self): return self.macros
    def set_macros(self, macros): self.macros = macros
    def get_volume(self): return self.volume
    def set_volume(self, volume): self.volume = volume
    def get_surface(self): return self.surface
    def set_surface(self, surface): self.surface = surface
    def get_preprocessor(self): return self.preprocessor
    def set_preprocessor(self, preprocessor): self.preprocessor = preprocessor
    def get_postprocessor(self): return self.postprocessor
    def set_postprocessor(self, postprocessor): self.postprocessor = postprocessor
    def export(self, outfile, level, namespace_='', name_='module', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='module')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='module'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='module', fromsubclass_=False):
        if self.general is not None:
            self.general.export(outfile, level, namespace_, name_='general', )
        if self.constants is not None:
            self.constants.export(outfile, level, namespace_, name_='constants', )
        if self.macros is not None:
            self.macros.export(outfile, level, namespace_, name_='macros', )
        if self.volume is not None:
            self.volume.export(outfile, level, namespace_, name_='volume', )
        if self.surface is not None:
            self.surface.export(outfile, level, namespace_, name_='surface', )
        if self.preprocessor is not None:
            self.preprocessor.export(outfile, level, namespace_, name_='preprocessor', )
        if self.postprocessor is not None:
            self.postprocessor.export(outfile, level, namespace_, name_='postprocessor', )
    def hasContent_(self):
        if (
            self.general is not None or
            self.constants is not None or
            self.macros is not None or
            self.volume is not None or
            self.surface is not None or
            self.preprocessor is not None or
            self.postprocessor is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='module'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.general is not None:
            showIndent(outfile, level)
            outfile.write('general=model_.general(\n')
            self.general.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.constants is not None:
            showIndent(outfile, level)
            outfile.write('constants=model_.constants(\n')
            self.constants.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.macros is not None:
            showIndent(outfile, level)
            outfile.write('macros=model_.macros(\n')
            self.macros.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.volume is not None:
            showIndent(outfile, level)
            outfile.write('volume=model_.volume(\n')
            self.volume.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.surface is not None:
            showIndent(outfile, level)
            outfile.write('surface=model_.surface(\n')
            self.surface.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.preprocessor is not None:
            showIndent(outfile, level)
            outfile.write('preprocessor=model_.preprocessor(\n')
            self.preprocessor.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.postprocessor is not None:
            showIndent(outfile, level)
            outfile.write('postprocessor=model_.postprocessor(\n')
            self.postprocessor.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'general':
            obj_ = general.factory()
            obj_.build(child_)
            self.set_general(obj_)
        elif nodeName_ == 'constants':
            obj_ = constants.factory()
            obj_.build(child_)
            self.set_constants(obj_)
        elif nodeName_ == 'macros':
            obj_ = macros.factory()
            obj_.build(child_)
            self.set_macros(obj_)
        elif nodeName_ == 'volume':
            obj_ = volume.factory()
            obj_.build(child_)
            self.set_volume(obj_)
        elif nodeName_ == 'surface':
            obj_ = surface.factory()
            obj_.build(child_)
            self.set_surface(obj_)
        elif nodeName_ == 'preprocessor':
            obj_ = preprocessor.factory()
            obj_.build(child_)
            self.set_preprocessor(obj_)
        elif nodeName_ == 'postprocessor':
            obj_ = postprocessor.factory()
            obj_.build(child_)
            self.set_postprocessor(obj_)
# end class module


class general(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, deformed_shape=None, id=None, name=None, description=None, analyses=None):
        self.deformed_shape = _cast(int, deformed_shape)
        self.id = _cast(None, id)
        self.name = _cast(None, name)
        self.description = description
        self.analyses = analyses
    def factory(*args_, **kwargs_):
        if general.subclass:
            return general.subclass(*args_, **kwargs_)
        else:
            return general(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_description(self): return self.description
    def set_description(self, description): self.description = description
    def get_analyses(self): return self.analyses
    def set_analyses(self, analyses): self.analyses = analyses
    def get_deformed_shape(self): return self.deformed_shape
    def set_deformed_shape(self, deformed_shape): self.deformed_shape = deformed_shape
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def export(self, outfile, level, namespace_='', name_='general', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='general')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='general'):
        if self.deformed_shape is not None and 'deformed_shape' not in already_processed:
            already_processed.append('deformed_shape')
            outfile.write(' deformed_shape="%s"' % self.gds_format_integer(self.deformed_shape, input_name='deformed_shape'))
        if self.id is not None and 'id' not in already_processed:
            already_processed.append('id')
            outfile.write(' id=%s' % (quote_attrib(self.id), ))
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='general', fromsubclass_=False):
        if self.description is not None:
            showIndent(outfile, level)
            outfile.write('<%sdescription>%s</%sdescription>\n' % (namespace_, self.gds_format_string(quote_xml(self.description).encode(ExternalEncoding), input_name='description'), namespace_))
        if self.analyses is not None:
            self.analyses.export(outfile, level, namespace_, name_='analyses', )
    def hasContent_(self):
        if (
            self.description is not None or
            self.analyses is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='general'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.deformed_shape is not None and 'deformed_shape' not in already_processed:
            already_processed.append('deformed_shape')
            showIndent(outfile, level)
            outfile.write('deformed_shape = %d,\n' % (self.deformed_shape,))
        if self.id is not None and 'id' not in already_processed:
            already_processed.append('id')
            showIndent(outfile, level)
            outfile.write('id = "%s",\n' % (self.id,))
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            showIndent(outfile, level)
            outfile.write('name = "%s",\n' % (self.name,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.description is not None:
            showIndent(outfile, level)
            outfile.write('description=%s,\n' % quote_python(self.description).encode(ExternalEncoding))
        if self.analyses is not None:
            showIndent(outfile, level)
            outfile.write('analyses=model_.analyses(\n')
            self.analyses.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('deformed_shape', node)
        if value is not None and 'deformed_shape' not in already_processed:
            already_processed.append('deformed_shape')
            try:
                self.deformed_shape = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.append('id')
            self.id = value
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.append('name')
            self.name = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'description':
            description_ = child_.text
            description_ = self.gds_validate_string(description_, node, 'description')
            self.description = description_
        elif nodeName_ == 'analyses':
            obj_ = analyses.factory()
            obj_.build(child_)
            self.set_analyses(obj_)
# end class general


class analyses(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, analysis=None):
        if analysis is None:
            self.analysis = []
        else:
            self.analysis = analysis
    def factory(*args_, **kwargs_):
        if analyses.subclass:
            return analyses.subclass(*args_, **kwargs_)
        else:
            return analyses(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_analysis(self): return self.analysis
    def set_analysis(self, analysis): self.analysis = analysis
    def add_analysis(self, value): self.analysis.append(value)
    def insert_analysis(self, index, value): self.analysis[index] = value
    def export(self, outfile, level, namespace_='', name_='analyses', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='analyses')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='analyses'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='analyses', fromsubclass_=False):
        for analysis_ in self.analysis:
            analysis_.export(outfile, level, namespace_, name_='analysis')
    def hasContent_(self):
        if (
            self.analysis
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='analyses'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('analysis=[\n')
        level += 1
        for analysis_ in self.analysis:
            showIndent(outfile, level)
            outfile.write('model_.analysis(\n')
            analysis_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'analysis':
            obj_ = analysis.factory()
            obj_.build(child_)
            self.analysis.append(obj_)
# end class analyses


class analysis(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, type_=None, solutions=None, id=None, name=None):
        self.type_ = _cast(None, type_)
        self.solutions = _cast(int, solutions)
        self.id = _cast(None, id)
        self.name = _cast(None, name)
        pass
    def factory(*args_, **kwargs_):
        if analysis.subclass:
            return analysis.subclass(*args_, **kwargs_)
        else:
            return analysis(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    def get_solutions(self): return self.solutions
    def set_solutions(self, solutions): self.solutions = solutions
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def export(self, outfile, level, namespace_='', name_='analysis', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='analysis')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='analysis'):
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.append('type_')
            outfile.write(' type=%s' % (quote_attrib(self.type_), ))
        if self.solutions is not None and 'solutions' not in already_processed:
            already_processed.append('solutions')
            outfile.write(' solutions="%s"' % self.gds_format_integer(self.solutions, input_name='solutions'))
        if self.id is not None and 'id' not in already_processed:
            already_processed.append('id')
            outfile.write(' id=%s' % (quote_attrib(self.id), ))
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='analysis', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='analysis'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.append('type_')
            showIndent(outfile, level)
            outfile.write('type_ = "%s",\n' % (self.type_,))
        if self.solutions is not None and 'solutions' not in already_processed:
            already_processed.append('solutions')
            showIndent(outfile, level)
            outfile.write('solutions = %d,\n' % (self.solutions,))
        if self.id is not None and 'id' not in already_processed:
            already_processed.append('id')
            showIndent(outfile, level)
            outfile.write('id = "%s",\n' % (self.id,))
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            showIndent(outfile, level)
            outfile.write('name = "%s",\n' % (self.name,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.append('type')
            self.type_ = value
        value = find_attr_value_('solutions', node)
        if value is not None and 'solutions' not in already_processed:
            already_processed.append('solutions')
            try:
                self.solutions = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.append('id')
            self.id = value
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.append('name')
            self.name = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class analysis


class constants(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, constant=None):
        if constant is None:
            self.constant = []
        else:
            self.constant = constant
    def factory(*args_, **kwargs_):
        if constants.subclass:
            return constants.subclass(*args_, **kwargs_)
        else:
            return constants(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_constant(self): return self.constant
    def set_constant(self, constant): self.constant = constant
    def add_constant(self, value): self.constant.append(value)
    def insert_constant(self, index, value): self.constant[index] = value
    def export(self, outfile, level, namespace_='', name_='constants', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='constants')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='constants'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='constants', fromsubclass_=False):
        for constant_ in self.constant:
            constant_.export(outfile, level, namespace_, name_='constant')
    def hasContent_(self):
        if (
            self.constant
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='constants'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('constant=[\n')
        level += 1
        for constant_ in self.constant:
            showIndent(outfile, level)
            outfile.write('model_.constant(\n')
            constant_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'constant':
            obj_ = constant.factory()
            obj_.build(child_)
            self.constant.append(obj_)
# end class constants


class constant(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, id=None, value=None):
        self.id = _cast(None, id)
        self.value = _cast(float, value)
        pass
    def factory(*args_, **kwargs_):
        if constant.subclass:
            return constant.subclass(*args_, **kwargs_)
        else:
            return constant(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_value(self): return self.value
    def set_value(self, value): self.value = value
    def export(self, outfile, level, namespace_='', name_='constant', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='constant')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='constant'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.append('id')
            outfile.write(' id=%s' % (quote_attrib(self.id), ))
        if self.value is not None and 'value' not in already_processed:
            already_processed.append('value')
            outfile.write(' value="%s"' % self.gds_format_double(self.value, input_name='value'))
    def exportChildren(self, outfile, level, namespace_='', name_='constant', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='constant'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.id is not None and 'id' not in already_processed:
            already_processed.append('id')
            showIndent(outfile, level)
            outfile.write('id = "%s",\n' % (self.id,))
        if self.value is not None and 'value' not in already_processed:
            already_processed.append('value')
            showIndent(outfile, level)
            outfile.write('value = %e,\n' % (self.value,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.append('id')
            self.id = value
        value = find_attr_value_('value', node)
        if value is not None and 'value' not in already_processed:
            already_processed.append('value')
            try:
                self.value = float(value)
            except ValueError, exp:
                raise ValueError('Bad float/double attribute (value): %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class constant


class macros(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, macro=None):
        self.macro = macro
    def factory(*args_, **kwargs_):
        if macros.subclass:
            return macros.subclass(*args_, **kwargs_)
        else:
            return macros(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_macro(self): return self.macro
    def set_macro(self, macro): self.macro = macro
    def export(self, outfile, level, namespace_='', name_='macros', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='macros')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='macros'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='macros', fromsubclass_=False):
        if self.macro is not None:
            self.macro.export(outfile, level, namespace_, name_='macro', )
    def hasContent_(self):
        if (
            self.macro is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='macros'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.macro is not None:
            showIndent(outfile, level)
            outfile.write('macro=model_.macro(\n')
            self.macro.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'macro':
            obj_ = macro.factory()
            obj_.build(child_)
            self.set_macro(obj_)
# end class macros


class macro(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, expression=None, id=None):
        self.expression = _cast(None, expression)
        self.id = _cast(None, id)
        pass
    def factory(*args_, **kwargs_):
        if macro.subclass:
            return macro.subclass(*args_, **kwargs_)
        else:
            return macro(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_expression(self): return self.expression
    def set_expression(self, expression): self.expression = expression
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def export(self, outfile, level, namespace_='', name_='macro', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='macro')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='macro'):
        if self.expression is not None and 'expression' not in already_processed:
            already_processed.append('expression')
            outfile.write(' expression=%s' % (self.gds_format_string(quote_attrib(self.expression).encode(ExternalEncoding), input_name='expression'), ))
        if self.id is not None and 'id' not in already_processed:
            already_processed.append('id')
            outfile.write(' id=%s' % (self.gds_format_string(quote_attrib(self.id).encode(ExternalEncoding), input_name='id'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='macro', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='macro'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.expression is not None and 'expression' not in already_processed:
            already_processed.append('expression')
            showIndent(outfile, level)
            outfile.write('expression = "%s",\n' % (self.expression,))
        if self.id is not None and 'id' not in already_processed:
            already_processed.append('id')
            showIndent(outfile, level)
            outfile.write('id = "%s",\n' % (self.id,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('expression', node)
        if value is not None and 'expression' not in already_processed:
            already_processed.append('expression')
            self.expression = value
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.append('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class macro


class preprocessor(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, volume=None, surface=None):
        self.volume = volume
        self.surface = surface
    def factory(*args_, **kwargs_):
        if preprocessor.subclass:
            return preprocessor.subclass(*args_, **kwargs_)
        else:
            return preprocessor(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_volume(self): return self.volume
    def set_volume(self, volume): self.volume = volume
    def get_surface(self): return self.surface
    def set_surface(self, surface): self.surface = surface
    def export(self, outfile, level, namespace_='', name_='preprocessor', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='preprocessor')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='preprocessor'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='preprocessor', fromsubclass_=False):
        if self.volume is not None:
            self.volume.export(outfile, level, namespace_, name_='volume', )
        if self.surface is not None:
            self.surface.export(outfile, level, namespace_, name_='surface', )
    def hasContent_(self):
        if (
            self.volume is not None or
            self.surface is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='preprocessor'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.volume is not None:
            showIndent(outfile, level)
            outfile.write('volume=model_.volume(\n')
            self.volume.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.surface is not None:
            showIndent(outfile, level)
            outfile.write('surface=model_.surface(\n')
            self.surface.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'volume':
            obj_ = volume.factory()
            obj_.build(child_)
            self.set_volume(obj_)
        elif nodeName_ == 'surface':
            obj_ = surface.factory()
            obj_.build(child_)
            self.set_surface(obj_)
# end class preprocessor


class postprocessor(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, localvariables=None, view=None, volumeintegrals=None, surfaceintegrals=None):
        self.localvariables = localvariables
        self.view = view
        self.volumeintegrals = volumeintegrals
        self.surfaceintegrals = surfaceintegrals
    def factory(*args_, **kwargs_):
        if postprocessor.subclass:
            return postprocessor.subclass(*args_, **kwargs_)
        else:
            return postprocessor(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_localvariables(self): return self.localvariables
    def set_localvariables(self, localvariables): self.localvariables = localvariables
    def get_view(self): return self.view
    def set_view(self, view): self.view = view
    def get_volumeintegrals(self): return self.volumeintegrals
    def set_volumeintegrals(self, volumeintegrals): self.volumeintegrals = volumeintegrals
    def get_surfaceintegrals(self): return self.surfaceintegrals
    def set_surfaceintegrals(self, surfaceintegrals): self.surfaceintegrals = surfaceintegrals
    def export(self, outfile, level, namespace_='', name_='postprocessor', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='postprocessor')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='postprocessor'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='postprocessor', fromsubclass_=False):
        if self.localvariables is not None:
            self.localvariables.export(outfile, level, namespace_, name_='localvariables', )
        if self.view is not None:
            self.view.export(outfile, level, namespace_, name_='view', )
        if self.volumeintegrals is not None:
            self.volumeintegrals.export(outfile, level, namespace_, name_='volumeintegrals', )
        if self.surfaceintegrals is not None:
            self.surfaceintegrals.export(outfile, level, namespace_, name_='surfaceintegrals', )
    def hasContent_(self):
        if (
            self.localvariables is not None or
            self.view is not None or
            self.volumeintegrals is not None or
            self.surfaceintegrals is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='postprocessor'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.localvariables is not None:
            showIndent(outfile, level)
            outfile.write('localvariables=model_.localvariables(\n')
            self.localvariables.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.view is not None:
            showIndent(outfile, level)
            outfile.write('view=model_.view(\n')
            self.view.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.volumeintegrals is not None:
            showIndent(outfile, level)
            outfile.write('volumeintegrals=model_.volumeintegrals(\n')
            self.volumeintegrals.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.surfaceintegrals is not None:
            showIndent(outfile, level)
            outfile.write('surfaceintegrals=model_.surfaceintegrals(\n')
            self.surfaceintegrals.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'localvariables':
            obj_ = localvariables.factory()
            obj_.build(child_)
            self.set_localvariables(obj_)
        elif nodeName_ == 'view':
            obj_ = view.factory()
            obj_.build(child_)
            self.set_view(obj_)
        elif nodeName_ == 'volumeintegrals':
            obj_ = volumeintegrals.factory()
            obj_.build(child_)
            self.set_volumeintegrals(obj_)
        elif nodeName_ == 'surfaceintegrals':
            obj_ = surfaceintegrals.factory()
            obj_.build(child_)
            self.set_surfaceintegrals(obj_)
# end class postprocessor


class localvariables(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, localvariable=None):
        if localvariable is None:
            self.localvariable = []
        else:
            self.localvariable = localvariable
    def factory(*args_, **kwargs_):
        if localvariables.subclass:
            return localvariables.subclass(*args_, **kwargs_)
        else:
            return localvariables(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_localvariable(self): return self.localvariable
    def set_localvariable(self, localvariable): self.localvariable = localvariable
    def add_localvariable(self, value): self.localvariable.append(value)
    def insert_localvariable(self, index, value): self.localvariable[index] = value
    def export(self, outfile, level, namespace_='', name_='localvariables', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='localvariables')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='localvariables'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='localvariables', fromsubclass_=False):
        for localvariable_ in self.localvariable:
            localvariable_.export(outfile, level, namespace_, name_='localvariable')
    def hasContent_(self):
        if (
            self.localvariable
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='localvariables'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('localvariable=[\n')
        level += 1
        for localvariable_ in self.localvariable:
            showIndent(outfile, level)
            outfile.write('model_.localvariable(\n')
            localvariable_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'localvariable':
            obj_ = localvariable.factory()
            obj_.build(child_)
            self.localvariable.append(obj_)
# end class localvariables


class localvariable(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, unit_html=None, name=None, format=None, shortname_latex=None, shortname_html=None, unit_latex=None, shortname=None, type_=None, id=None, unit=None, expression=None):
        self.unit_html = _cast(None, unit_html)
        self.name = _cast(None, name)
        self.format = _cast(None, format)
        self.shortname_latex = _cast(None, shortname_latex)
        self.shortname_html = _cast(None, shortname_html)
        self.unit_latex = _cast(None, unit_latex)
        self.shortname = _cast(None, shortname)
        self.type_ = _cast(None, type_)
        self.id = _cast(None, id)
        self.unit = _cast(None, unit)
        if expression is None:
            self.expression = []
        else:
            self.expression = expression
    def factory(*args_, **kwargs_):
        if localvariable.subclass:
            return localvariable.subclass(*args_, **kwargs_)
        else:
            return localvariable(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_expression(self): return self.expression
    def set_expression(self, expression): self.expression = expression
    def add_expression(self, value): self.expression.append(value)
    def insert_expression(self, index, value): self.expression[index] = value
    def get_unit_html(self): return self.unit_html
    def set_unit_html(self, unit_html): self.unit_html = unit_html
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_format(self): return self.format
    def set_format(self, format): self.format = format
    def get_shortname_latex(self): return self.shortname_latex
    def set_shortname_latex(self, shortname_latex): self.shortname_latex = shortname_latex
    def get_shortname_html(self): return self.shortname_html
    def set_shortname_html(self, shortname_html): self.shortname_html = shortname_html
    def get_unit_latex(self): return self.unit_latex
    def set_unit_latex(self, unit_latex): self.unit_latex = unit_latex
    def get_shortname(self): return self.shortname
    def set_shortname(self, shortname): self.shortname = shortname
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_unit(self): return self.unit
    def set_unit(self, unit): self.unit = unit
    def export(self, outfile, level, namespace_='', name_='localvariable', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='localvariable')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='localvariable'):
        if self.unit_html is not None and 'unit_html' not in already_processed:
            already_processed.append('unit_html')
            outfile.write(' unit_html=%s' % (self.gds_format_string(quote_attrib(self.unit_html).encode(ExternalEncoding), input_name='unit_html'), ))
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
        if self.format is not None and 'format' not in already_processed:
            already_processed.append('format')
            outfile.write(' format=%s' % (self.gds_format_string(quote_attrib(self.format).encode(ExternalEncoding), input_name='format'), ))
        if self.shortname_latex is not None and 'shortname_latex' not in already_processed:
            already_processed.append('shortname_latex')
            outfile.write(' shortname_latex=%s' % (self.gds_format_string(quote_attrib(self.shortname_latex).encode(ExternalEncoding), input_name='shortname_latex'), ))
        if self.shortname_html is not None and 'shortname_html' not in already_processed:
            already_processed.append('shortname_html')
            outfile.write(' shortname_html=%s' % (self.gds_format_string(quote_attrib(self.shortname_html).encode(ExternalEncoding), input_name='shortname_html'), ))
        if self.unit_latex is not None and 'unit_latex' not in already_processed:
            already_processed.append('unit_latex')
            outfile.write(' unit_latex=%s' % (self.gds_format_string(quote_attrib(self.unit_latex).encode(ExternalEncoding), input_name='unit_latex'), ))
        if self.shortname is not None and 'shortname' not in already_processed:
            already_processed.append('shortname')
            outfile.write(' shortname=%s' % (quote_attrib(self.shortname), ))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.append('type_')
            outfile.write(' type=%s' % (quote_attrib(self.type_), ))
        if self.id is not None and 'id' not in already_processed:
            already_processed.append('id')
            outfile.write(' id=%s' % (quote_attrib(self.id), ))
        if self.unit is not None and 'unit' not in already_processed:
            already_processed.append('unit')
            outfile.write(' unit=%s' % (self.gds_format_string(quote_attrib(self.unit).encode(ExternalEncoding), input_name='unit'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='localvariable', fromsubclass_=False):
        for expression_ in self.expression:
            expression_.export(outfile, level, namespace_, name_='expression')
    def hasContent_(self):
        if (
            self.expression
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='localvariable'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.unit_html is not None and 'unit_html' not in already_processed:
            already_processed.append('unit_html')
            showIndent(outfile, level)
            outfile.write('unit_html = "%s",\n' % (self.unit_html,))
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            showIndent(outfile, level)
            outfile.write('name = "%s",\n' % (self.name,))
        if self.format is not None and 'format' not in already_processed:
            already_processed.append('format')
            showIndent(outfile, level)
            outfile.write('format = "%s",\n' % (self.format,))
        if self.shortname_latex is not None and 'shortname_latex' not in already_processed:
            already_processed.append('shortname_latex')
            showIndent(outfile, level)
            outfile.write('shortname_latex = "%s",\n' % (self.shortname_latex,))
        if self.shortname_html is not None and 'shortname_html' not in already_processed:
            already_processed.append('shortname_html')
            showIndent(outfile, level)
            outfile.write('shortname_html = "%s",\n' % (self.shortname_html,))
        if self.unit_latex is not None and 'unit_latex' not in already_processed:
            already_processed.append('unit_latex')
            showIndent(outfile, level)
            outfile.write('unit_latex = "%s",\n' % (self.unit_latex,))
        if self.shortname is not None and 'shortname' not in already_processed:
            already_processed.append('shortname')
            showIndent(outfile, level)
            outfile.write('shortname = "%s",\n' % (self.shortname,))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.append('type_')
            showIndent(outfile, level)
            outfile.write('type_ = "%s",\n' % (self.type_,))
        if self.id is not None and 'id' not in already_processed:
            already_processed.append('id')
            showIndent(outfile, level)
            outfile.write('id = "%s",\n' % (self.id,))
        if self.unit is not None and 'unit' not in already_processed:
            already_processed.append('unit')
            showIndent(outfile, level)
            outfile.write('unit = "%s",\n' % (self.unit,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('expression=[\n')
        level += 1
        for expression_ in self.expression:
            showIndent(outfile, level)
            outfile.write('model_.expression(\n')
            expression_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('unit_html', node)
        if value is not None and 'unit_html' not in already_processed:
            already_processed.append('unit_html')
            self.unit_html = value
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.append('name')
            self.name = value
        value = find_attr_value_('format', node)
        if value is not None and 'format' not in already_processed:
            already_processed.append('format')
            self.format = value
        value = find_attr_value_('shortname_latex', node)
        if value is not None and 'shortname_latex' not in already_processed:
            already_processed.append('shortname_latex')
            self.shortname_latex = value
        value = find_attr_value_('shortname_html', node)
        if value is not None and 'shortname_html' not in already_processed:
            already_processed.append('shortname_html')
            self.shortname_html = value
        value = find_attr_value_('unit_latex', node)
        if value is not None and 'unit_latex' not in already_processed:
            already_processed.append('unit_latex')
            self.unit_latex = value
        value = find_attr_value_('shortname', node)
        if value is not None and 'shortname' not in already_processed:
            already_processed.append('shortname')
            self.shortname = value
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.append('type')
            self.type_ = value
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.append('id')
            self.id = value
        value = find_attr_value_('unit', node)
        if value is not None and 'unit' not in already_processed:
            already_processed.append('unit')
            self.unit = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'expression':
            obj_ = expression.factory()
            obj_.build(child_)
            self.expression.append(obj_)
# end class localvariable


class view(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, scalar=None, vector=None):
        self.scalar = scalar
        self.vector = vector
    def factory(*args_, **kwargs_):
        if view.subclass:
            return view.subclass(*args_, **kwargs_)
        else:
            return view(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_scalar(self): return self.scalar
    def set_scalar(self, scalar): self.scalar = scalar
    def get_vector(self): return self.vector
    def set_vector(self, vector): self.vector = vector
    def export(self, outfile, level, namespace_='', name_='view', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='view')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='view'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='view', fromsubclass_=False):
        if self.scalar is not None:
            self.scalar.export(outfile, level, namespace_, name_='scalar', )
        if self.vector is not None:
            self.vector.export(outfile, level, namespace_, name_='vector', )
    def hasContent_(self):
        if (
            self.scalar is not None or
            self.vector is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='view'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.scalar is not None:
            showIndent(outfile, level)
            outfile.write('scalar=model_.scalar(\n')
            self.scalar.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.vector is not None:
            showIndent(outfile, level)
            outfile.write('vector=model_.vector(\n')
            self.vector.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'scalar':
            obj_ = scalar.factory()
            obj_.build(child_)
            self.set_scalar(obj_)
        elif nodeName_ == 'vector':
            obj_ = vector.factory()
            obj_.build(child_)
            self.set_vector(obj_)
# end class view


class scalar(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, default=None):
        if default is None:
            self.default = []
        else:
            self.default = default
    def factory(*args_, **kwargs_):
        if scalar.subclass:
            return scalar.subclass(*args_, **kwargs_)
        else:
            return scalar(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_default(self): return self.default
    def set_default(self, default): self.default = default
    def add_default(self, value): self.default.append(value)
    def insert_default(self, index, value): self.default[index] = value
    def export(self, outfile, level, namespace_='', name_='scalar', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='scalar')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='scalar'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='scalar', fromsubclass_=False):
        for default_ in self.default:
            default_.export(outfile, level, namespace_, name_='default')
    def hasContent_(self):
        if (
            self.default
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='scalar'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('default=[\n')
        level += 1
        for default_ in self.default:
            showIndent(outfile, level)
            outfile.write('model_.default(\n')
            default_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'default':
            obj_ = default.factory()
            obj_.build(child_)
            self.default.append(obj_)
# end class scalar


class volumeintegrals(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, volumeintegral=None):
        if volumeintegral is None:
            self.volumeintegral = []
        else:
            self.volumeintegral = volumeintegral
    def factory(*args_, **kwargs_):
        if volumeintegrals.subclass:
            return volumeintegrals.subclass(*args_, **kwargs_)
        else:
            return volumeintegrals(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_volumeintegral(self): return self.volumeintegral
    def set_volumeintegral(self, volumeintegral): self.volumeintegral = volumeintegral
    def add_volumeintegral(self, value): self.volumeintegral.append(value)
    def insert_volumeintegral(self, index, value): self.volumeintegral[index] = value
    def export(self, outfile, level, namespace_='', name_='volumeintegrals', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='volumeintegrals')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='volumeintegrals'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='volumeintegrals', fromsubclass_=False):
        for volumeintegral_ in self.volumeintegral:
            volumeintegral_.export(outfile, level, namespace_, name_='volumeintegral')
    def hasContent_(self):
        if (
            self.volumeintegral
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='volumeintegrals'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('volumeintegral=[\n')
        level += 1
        for volumeintegral_ in self.volumeintegral:
            showIndent(outfile, level)
            outfile.write('model_.volumeintegral(\n')
            volumeintegral_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'volumeintegral':
            obj_ = volumeintegral.factory()
            obj_.build(child_)
            self.volumeintegral.append(obj_)
# end class volumeintegrals


class volumeintegral(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, unit_html=None, name=None, shortname_latex=None, shortname_html=None, unit_latex=None, shortname=None, id=None, unit=None, expression=None):
        self.unit_html = _cast(None, unit_html)
        self.name = _cast(None, name)
        self.shortname_latex = _cast(None, shortname_latex)
        self.shortname_html = _cast(None, shortname_html)
        self.unit_latex = _cast(None, unit_latex)
        self.shortname = _cast(None, shortname)
        self.id = _cast(None, id)
        self.unit = _cast(None, unit)
        if expression is None:
            self.expression = []
        else:
            self.expression = expression
    def factory(*args_, **kwargs_):
        if volumeintegral.subclass:
            return volumeintegral.subclass(*args_, **kwargs_)
        else:
            return volumeintegral(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_expression(self): return self.expression
    def set_expression(self, expression): self.expression = expression
    def add_expression(self, value): self.expression.append(value)
    def insert_expression(self, index, value): self.expression[index] = value
    def get_unit_html(self): return self.unit_html
    def set_unit_html(self, unit_html): self.unit_html = unit_html
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_shortname_latex(self): return self.shortname_latex
    def set_shortname_latex(self, shortname_latex): self.shortname_latex = shortname_latex
    def get_shortname_html(self): return self.shortname_html
    def set_shortname_html(self, shortname_html): self.shortname_html = shortname_html
    def get_unit_latex(self): return self.unit_latex
    def set_unit_latex(self, unit_latex): self.unit_latex = unit_latex
    def get_shortname(self): return self.shortname
    def set_shortname(self, shortname): self.shortname = shortname
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_unit(self): return self.unit
    def set_unit(self, unit): self.unit = unit
    def export(self, outfile, level, namespace_='', name_='volumeintegral', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='volumeintegral')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='volumeintegral'):
        if self.unit_html is not None and 'unit_html' not in already_processed:
            already_processed.append('unit_html')
            outfile.write(' unit_html=%s' % (self.gds_format_string(quote_attrib(self.unit_html).encode(ExternalEncoding), input_name='unit_html'), ))
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
        if self.shortname_latex is not None and 'shortname_latex' not in already_processed:
            already_processed.append('shortname_latex')
            outfile.write(' shortname_latex=%s' % (self.gds_format_string(quote_attrib(self.shortname_latex).encode(ExternalEncoding), input_name='shortname_latex'), ))
        if self.shortname_html is not None and 'shortname_html' not in already_processed:
            already_processed.append('shortname_html')
            outfile.write(' shortname_html=%s' % (self.gds_format_string(quote_attrib(self.shortname_html).encode(ExternalEncoding), input_name='shortname_html'), ))
        if self.unit_latex is not None and 'unit_latex' not in already_processed:
            already_processed.append('unit_latex')
            outfile.write(' unit_latex=%s' % (self.gds_format_string(quote_attrib(self.unit_latex).encode(ExternalEncoding), input_name='unit_latex'), ))
        if self.shortname is not None and 'shortname' not in already_processed:
            already_processed.append('shortname')
            outfile.write(' shortname=%s' % (quote_attrib(self.shortname), ))
        if self.id is not None and 'id' not in already_processed:
            already_processed.append('id')
            outfile.write(' id=%s' % (quote_attrib(self.id), ))
        if self.unit is not None and 'unit' not in already_processed:
            already_processed.append('unit')
            outfile.write(' unit=%s' % (quote_attrib(self.unit), ))
    def exportChildren(self, outfile, level, namespace_='', name_='volumeintegral', fromsubclass_=False):
        for expression_ in self.expression:
            expression_.export(outfile, level, namespace_, name_='expression')
    def hasContent_(self):
        if (
            self.expression
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='volumeintegral'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.unit_html is not None and 'unit_html' not in already_processed:
            already_processed.append('unit_html')
            showIndent(outfile, level)
            outfile.write('unit_html = "%s",\n' % (self.unit_html,))
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            showIndent(outfile, level)
            outfile.write('name = "%s",\n' % (self.name,))
        if self.shortname_latex is not None and 'shortname_latex' not in already_processed:
            already_processed.append('shortname_latex')
            showIndent(outfile, level)
            outfile.write('shortname_latex = "%s",\n' % (self.shortname_latex,))
        if self.shortname_html is not None and 'shortname_html' not in already_processed:
            already_processed.append('shortname_html')
            showIndent(outfile, level)
            outfile.write('shortname_html = "%s",\n' % (self.shortname_html,))
        if self.unit_latex is not None and 'unit_latex' not in already_processed:
            already_processed.append('unit_latex')
            showIndent(outfile, level)
            outfile.write('unit_latex = "%s",\n' % (self.unit_latex,))
        if self.shortname is not None and 'shortname' not in already_processed:
            already_processed.append('shortname')
            showIndent(outfile, level)
            outfile.write('shortname = "%s",\n' % (self.shortname,))
        if self.id is not None and 'id' not in already_processed:
            already_processed.append('id')
            showIndent(outfile, level)
            outfile.write('id = "%s",\n' % (self.id,))
        if self.unit is not None and 'unit' not in already_processed:
            already_processed.append('unit')
            showIndent(outfile, level)
            outfile.write('unit = "%s",\n' % (self.unit,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('expression=[\n')
        level += 1
        for expression_ in self.expression:
            showIndent(outfile, level)
            outfile.write('model_.expression(\n')
            expression_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('unit_html', node)
        if value is not None and 'unit_html' not in already_processed:
            already_processed.append('unit_html')
            self.unit_html = value
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.append('name')
            self.name = value
        value = find_attr_value_('shortname_latex', node)
        if value is not None and 'shortname_latex' not in already_processed:
            already_processed.append('shortname_latex')
            self.shortname_latex = value
        value = find_attr_value_('shortname_html', node)
        if value is not None and 'shortname_html' not in already_processed:
            already_processed.append('shortname_html')
            self.shortname_html = value
        value = find_attr_value_('unit_latex', node)
        if value is not None and 'unit_latex' not in already_processed:
            already_processed.append('unit_latex')
            self.unit_latex = value
        value = find_attr_value_('shortname', node)
        if value is not None and 'shortname' not in already_processed:
            already_processed.append('shortname')
            self.shortname = value
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.append('id')
            self.id = value
        value = find_attr_value_('unit', node)
        if value is not None and 'unit' not in already_processed:
            already_processed.append('unit')
            self.unit = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'expression':
            obj_ = expression.factory()
            obj_.build(child_)
            self.expression.append(obj_)
# end class volumeintegral


class surfaceintegrals(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, surfaceintegral=None):
        if surfaceintegral is None:
            self.surfaceintegral = []
        else:
            self.surfaceintegral = surfaceintegral
    def factory(*args_, **kwargs_):
        if surfaceintegrals.subclass:
            return surfaceintegrals.subclass(*args_, **kwargs_)
        else:
            return surfaceintegrals(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_surfaceintegral(self): return self.surfaceintegral
    def set_surfaceintegral(self, surfaceintegral): self.surfaceintegral = surfaceintegral
    def add_surfaceintegral(self, value): self.surfaceintegral.append(value)
    def insert_surfaceintegral(self, index, value): self.surfaceintegral[index] = value
    def export(self, outfile, level, namespace_='', name_='surfaceintegrals', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='surfaceintegrals')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='surfaceintegrals'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='surfaceintegrals', fromsubclass_=False):
        for surfaceintegral_ in self.surfaceintegral:
            surfaceintegral_.export(outfile, level, namespace_, name_='surfaceintegral')
    def hasContent_(self):
        if (
            self.surfaceintegral
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='surfaceintegrals'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('surfaceintegral=[\n')
        level += 1
        for surfaceintegral_ in self.surfaceintegral:
            showIndent(outfile, level)
            outfile.write('model_.surfaceintegral(\n')
            surfaceintegral_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'surfaceintegral':
            obj_ = surfaceintegral.factory()
            obj_.build(child_)
            self.surfaceintegral.append(obj_)
# end class surfaceintegrals


class surfaceintegral(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, unit_html=None, name=None, shortname_html=None, unit_latex=None, shortname=None, id=None, unit=None, expression=None):
        self.unit_html = _cast(None, unit_html)
        self.name = _cast(None, name)
        self.shortname_html = _cast(None, shortname_html)
        self.unit_latex = _cast(None, unit_latex)
        self.shortname = _cast(None, shortname)
        self.id = _cast(None, id)
        self.unit = _cast(None, unit)
        if expression is None:
            self.expression = []
        else:
            self.expression = expression
    def factory(*args_, **kwargs_):
        if surfaceintegral.subclass:
            return surfaceintegral.subclass(*args_, **kwargs_)
        else:
            return surfaceintegral(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_expression(self): return self.expression
    def set_expression(self, expression): self.expression = expression
    def add_expression(self, value): self.expression.append(value)
    def insert_expression(self, index, value): self.expression[index] = value
    def get_unit_html(self): return self.unit_html
    def set_unit_html(self, unit_html): self.unit_html = unit_html
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_shortname_html(self): return self.shortname_html
    def set_shortname_html(self, shortname_html): self.shortname_html = shortname_html
    def get_unit_latex(self): return self.unit_latex
    def set_unit_latex(self, unit_latex): self.unit_latex = unit_latex
    def get_shortname(self): return self.shortname
    def set_shortname(self, shortname): self.shortname = shortname
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_unit(self): return self.unit
    def set_unit(self, unit): self.unit = unit
    def export(self, outfile, level, namespace_='', name_='surfaceintegral', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='surfaceintegral')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='surfaceintegral'):
        if self.unit_html is not None and 'unit_html' not in already_processed:
            already_processed.append('unit_html')
            outfile.write(' unit_html=%s' % (self.gds_format_string(quote_attrib(self.unit_html).encode(ExternalEncoding), input_name='unit_html'), ))
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
        if self.shortname_html is not None and 'shortname_html' not in already_processed:
            already_processed.append('shortname_html')
            outfile.write(' shortname_html=%s' % (self.gds_format_string(quote_attrib(self.shortname_html).encode(ExternalEncoding), input_name='shortname_html'), ))
        if self.unit_latex is not None and 'unit_latex' not in already_processed:
            already_processed.append('unit_latex')
            outfile.write(' unit_latex=%s' % (self.gds_format_string(quote_attrib(self.unit_latex).encode(ExternalEncoding), input_name='unit_latex'), ))
        if self.shortname is not None and 'shortname' not in already_processed:
            already_processed.append('shortname')
            outfile.write(' shortname=%s' % (quote_attrib(self.shortname), ))
        if self.id is not None and 'id' not in already_processed:
            already_processed.append('id')
            outfile.write(' id=%s' % (quote_attrib(self.id), ))
        if self.unit is not None and 'unit' not in already_processed:
            already_processed.append('unit')
            outfile.write(' unit=%s' % (quote_attrib(self.unit), ))
    def exportChildren(self, outfile, level, namespace_='', name_='surfaceintegral', fromsubclass_=False):
        for expression_ in self.expression:
            expression_.export(outfile, level, namespace_, name_='expression')
    def hasContent_(self):
        if (
            self.expression
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='surfaceintegral'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.unit_html is not None and 'unit_html' not in already_processed:
            already_processed.append('unit_html')
            showIndent(outfile, level)
            outfile.write('unit_html = "%s",\n' % (self.unit_html,))
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            showIndent(outfile, level)
            outfile.write('name = "%s",\n' % (self.name,))
        if self.shortname_html is not None and 'shortname_html' not in already_processed:
            already_processed.append('shortname_html')
            showIndent(outfile, level)
            outfile.write('shortname_html = "%s",\n' % (self.shortname_html,))
        if self.unit_latex is not None and 'unit_latex' not in already_processed:
            already_processed.append('unit_latex')
            showIndent(outfile, level)
            outfile.write('unit_latex = "%s",\n' % (self.unit_latex,))
        if self.shortname is not None and 'shortname' not in already_processed:
            already_processed.append('shortname')
            showIndent(outfile, level)
            outfile.write('shortname = "%s",\n' % (self.shortname,))
        if self.id is not None and 'id' not in already_processed:
            already_processed.append('id')
            showIndent(outfile, level)
            outfile.write('id = "%s",\n' % (self.id,))
        if self.unit is not None and 'unit' not in already_processed:
            already_processed.append('unit')
            showIndent(outfile, level)
            outfile.write('unit = "%s",\n' % (self.unit,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('expression=[\n')
        level += 1
        for expression_ in self.expression:
            showIndent(outfile, level)
            outfile.write('model_.expression(\n')
            expression_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('unit_html', node)
        if value is not None and 'unit_html' not in already_processed:
            already_processed.append('unit_html')
            self.unit_html = value
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.append('name')
            self.name = value
        value = find_attr_value_('shortname_html', node)
        if value is not None and 'shortname_html' not in already_processed:
            already_processed.append('shortname_html')
            self.shortname_html = value
        value = find_attr_value_('unit_latex', node)
        if value is not None and 'unit_latex' not in already_processed:
            already_processed.append('unit_latex')
            self.unit_latex = value
        value = find_attr_value_('shortname', node)
        if value is not None and 'shortname' not in already_processed:
            already_processed.append('shortname')
            self.shortname = value
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.append('id')
            self.id = value
        value = find_attr_value_('unit', node)
        if value is not None and 'unit' not in already_processed:
            already_processed.append('unit')
            self.unit = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'expression':
            obj_ = expression.factory()
            obj_.build(child_)
            self.expression.append(obj_)
# end class surfaceintegral


class volume(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, quantity=None, weakforms=None, group=None):
        if quantity is None:
            self.quantity = []
        else:
            self.quantity = quantity
        self.weakforms = weakforms
        if group is None:
            self.group = []
        else:
            self.group = group
    def factory(*args_, **kwargs_):
        if volume.subclass:
            return volume.subclass(*args_, **kwargs_)
        else:
            return volume(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_quantity(self): return self.quantity
    def set_quantity(self, quantity): self.quantity = quantity
    def add_quantity(self, value): self.quantity.append(value)
    def insert_quantity(self, index, value): self.quantity[index] = value
    def get_weakforms(self): return self.weakforms
    def set_weakforms(self, weakforms): self.weakforms = weakforms
    def get_group(self): return self.group
    def set_group(self, group): self.group = group
    def add_group(self, value): self.group.append(value)
    def insert_group(self, index, value): self.group[index] = value
    def export(self, outfile, level, namespace_='', name_='volume', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='volume')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='volume'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='volume', fromsubclass_=False):
        for quantity_ in self.quantity:
            quantity_.export(outfile, level, namespace_, name_='quantity')
        if self.weakforms is not None:
            self.weakforms.export(outfile, level, namespace_, name_='weakforms', )
        for group_ in self.group:
            group_.export(outfile, level, namespace_, name_='group')
    def hasContent_(self):
        if (
            self.quantity or
            self.weakforms is not None or
            self.group
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='volume'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('quantity=[\n')
        level += 1
        for quantity_ in self.quantity:
            showIndent(outfile, level)
            outfile.write('model_.quantity(\n')
            quantity_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.weakforms is not None:
            showIndent(outfile, level)
            outfile.write('weakforms=model_.weakforms(\n')
            self.weakforms.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('group=[\n')
        level += 1
        for group_ in self.group:
            showIndent(outfile, level)
            outfile.write('model_.group(\n')
            group_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'quantity':
            obj_ = quantity.factory()
            obj_.build(child_)
            self.quantity.append(obj_)
        elif nodeName_ == 'weakforms':
            obj_ = weakforms.factory()
            obj_.build(child_)
            self.set_weakforms(obj_)
        elif nodeName_ == 'group':
            obj_ = group.factory()
            obj_.build(child_)
            self.group.append(obj_)
# end class volume


class surface(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, group=None, quantity=None, weakforms=None):
        self.group = group
        if quantity is None:
            self.quantity = []
        else:
            self.quantity = quantity
        self.weakforms = weakforms
    def factory(*args_, **kwargs_):
        if surface.subclass:
            return surface.subclass(*args_, **kwargs_)
        else:
            return surface(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_group(self): return self.group
    def set_group(self, group): self.group = group
    def get_quantity(self): return self.quantity
    def set_quantity(self, quantity): self.quantity = quantity
    def add_quantity(self, value): self.quantity.append(value)
    def insert_quantity(self, index, value): self.quantity[index] = value
    def get_weakforms(self): return self.weakforms
    def set_weakforms(self, weakforms): self.weakforms = weakforms
    def export(self, outfile, level, namespace_='', name_='surface', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='surface')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='surface'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='surface', fromsubclass_=False):
        if self.group is not None:
            self.group.export(outfile, level, namespace_, name_='group', )
        for quantity_ in self.quantity:
            quantity_.export(outfile, level, namespace_, name_='quantity')
        if self.weakforms is not None:
            self.weakforms.export(outfile, level, namespace_, name_='weakforms', )
    def hasContent_(self):
        if (
            self.group is not None or
            self.quantity or
            self.weakforms is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='surface'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.group is not None:
            showIndent(outfile, level)
            outfile.write('group=model_.group(\n')
            self.group.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('quantity=[\n')
        level += 1
        for quantity_ in self.quantity:
            showIndent(outfile, level)
            outfile.write('model_.quantity(\n')
            quantity_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.weakforms is not None:
            showIndent(outfile, level)
            outfile.write('weakforms=model_.weakforms(\n')
            self.weakforms.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'group':
            obj_ = group.factory()
            obj_.build(child_)
            self.set_group(obj_)
        elif nodeName_ == 'quantity':
            obj_ = quantity.factory()
            obj_.build(child_)
            self.quantity.append(obj_)
        elif nodeName_ == 'weakforms':
            obj_ = weakforms.factory()
            obj_.build(child_)
            self.set_weakforms(obj_)
# end class surface


class expression(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, planar=None, planar_y=None, planar_x=None, axi_r=None, analysistype=None, axi=None, axi_z=None):
        self.planar = _cast(None, planar)
        self.planar_y = _cast(None, planar_y)
        self.planar_x = _cast(None, planar_x)
        self.axi_r = _cast(None, axi_r)
        self.analysistype = _cast(None, analysistype)
        self.axi = _cast(None, axi)
        self.axi_z = _cast(None, axi_z)
        pass
    def factory(*args_, **kwargs_):
        if expression.subclass:
            return expression.subclass(*args_, **kwargs_)
        else:
            return expression(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_planar(self): return self.planar
    def set_planar(self, planar): self.planar = planar
    def get_planar_y(self): return self.planar_y
    def set_planar_y(self, planar_y): self.planar_y = planar_y
    def get_planar_x(self): return self.planar_x
    def set_planar_x(self, planar_x): self.planar_x = planar_x
    def get_axi_r(self): return self.axi_r
    def set_axi_r(self, axi_r): self.axi_r = axi_r
    def get_analysistype(self): return self.analysistype
    def set_analysistype(self, analysistype): self.analysistype = analysistype
    def get_axi(self): return self.axi
    def set_axi(self, axi): self.axi = axi
    def get_axi_z(self): return self.axi_z
    def set_axi_z(self, axi_z): self.axi_z = axi_z
    def export(self, outfile, level, namespace_='', name_='expression', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='expression')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='expression'):
        if self.planar is not None and 'planar' not in already_processed:
            already_processed.append('planar')
            outfile.write(' planar=%s' % (self.gds_format_string(quote_attrib(self.planar).encode(ExternalEncoding), input_name='planar'), ))
        if self.planar_y is not None and 'planar_y' not in already_processed:
            already_processed.append('planar_y')
            outfile.write(' planar_y=%s' % (self.gds_format_string(quote_attrib(self.planar_y).encode(ExternalEncoding), input_name='planar_y'), ))
        if self.planar_x is not None and 'planar_x' not in already_processed:
            already_processed.append('planar_x')
            outfile.write(' planar_x=%s' % (self.gds_format_string(quote_attrib(self.planar_x).encode(ExternalEncoding), input_name='planar_x'), ))
        if self.axi_r is not None and 'axi_r' not in already_processed:
            already_processed.append('axi_r')
            outfile.write(' axi_r=%s' % (self.gds_format_string(quote_attrib(self.axi_r).encode(ExternalEncoding), input_name='axi_r'), ))
        if self.analysistype is not None and 'analysistype' not in already_processed:
            already_processed.append('analysistype')
            outfile.write(' analysistype=%s' % (quote_attrib(self.analysistype), ))
        if self.axi is not None and 'axi' not in already_processed:
            already_processed.append('axi')
            outfile.write(' axi=%s' % (self.gds_format_string(quote_attrib(self.axi).encode(ExternalEncoding), input_name='axi'), ))
        if self.axi_z is not None and 'axi_z' not in already_processed:
            already_processed.append('axi_z')
            outfile.write(' axi_z=%s' % (self.gds_format_string(quote_attrib(self.axi_z).encode(ExternalEncoding), input_name='axi_z'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='expression', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='expression'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.planar is not None and 'planar' not in already_processed:
            already_processed.append('planar')
            showIndent(outfile, level)
            outfile.write('planar = "%s",\n' % (self.planar,))
        if self.planar_y is not None and 'planar_y' not in already_processed:
            already_processed.append('planar_y')
            showIndent(outfile, level)
            outfile.write('planar_y = "%s",\n' % (self.planar_y,))
        if self.planar_x is not None and 'planar_x' not in already_processed:
            already_processed.append('planar_x')
            showIndent(outfile, level)
            outfile.write('planar_x = "%s",\n' % (self.planar_x,))
        if self.axi_r is not None and 'axi_r' not in already_processed:
            already_processed.append('axi_r')
            showIndent(outfile, level)
            outfile.write('axi_r = "%s",\n' % (self.axi_r,))
        if self.analysistype is not None and 'analysistype' not in already_processed:
            already_processed.append('analysistype')
            showIndent(outfile, level)
            outfile.write('analysistype = "%s",\n' % (self.analysistype,))
        if self.axi is not None and 'axi' not in already_processed:
            already_processed.append('axi')
            showIndent(outfile, level)
            outfile.write('axi = "%s",\n' % (self.axi,))
        if self.axi_z is not None and 'axi_z' not in already_processed:
            already_processed.append('axi_z')
            showIndent(outfile, level)
            outfile.write('axi_z = "%s",\n' % (self.axi_z,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('planar', node)
        if value is not None and 'planar' not in already_processed:
            already_processed.append('planar')
            self.planar = value
        value = find_attr_value_('planar_y', node)
        if value is not None and 'planar_y' not in already_processed:
            already_processed.append('planar_y')
            self.planar_y = value
        value = find_attr_value_('planar_x', node)
        if value is not None and 'planar_x' not in already_processed:
            already_processed.append('planar_x')
            self.planar_x = value
        value = find_attr_value_('axi_r', node)
        if value is not None and 'axi_r' not in already_processed:
            already_processed.append('axi_r')
            self.axi_r = value
        value = find_attr_value_('analysistype', node)
        if value is not None and 'analysistype' not in already_processed:
            already_processed.append('analysistype')
            self.analysistype = value
        value = find_attr_value_('axi', node)
        if value is not None and 'axi' not in already_processed:
            already_processed.append('axi')
            self.axi = value
        value = find_attr_value_('axi_z', node)
        if value is not None and 'axi_z' not in already_processed:
            already_processed.append('axi_z')
            self.axi_z = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class expression


class default(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, analysistype=None, id=None):
        self.analysistype = _cast(None, analysistype)
        self.id = _cast(None, id)
        pass
    def factory(*args_, **kwargs_):
        if default.subclass:
            return default.subclass(*args_, **kwargs_)
        else:
            return default(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_analysistype(self): return self.analysistype
    def set_analysistype(self, analysistype): self.analysistype = analysistype
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def export(self, outfile, level, namespace_='', name_='default', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='default')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='default'):
        if self.analysistype is not None and 'analysistype' not in already_processed:
            already_processed.append('analysistype')
            outfile.write(' analysistype=%s' % (quote_attrib(self.analysistype), ))
        if self.id is not None and 'id' not in already_processed:
            already_processed.append('id')
            outfile.write(' id=%s' % (quote_attrib(self.id), ))
    def exportChildren(self, outfile, level, namespace_='', name_='default', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='default'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.analysistype is not None and 'analysistype' not in already_processed:
            already_processed.append('analysistype')
            showIndent(outfile, level)
            outfile.write('analysistype = "%s",\n' % (self.analysistype,))
        if self.id is not None and 'id' not in already_processed:
            already_processed.append('id')
            showIndent(outfile, level)
            outfile.write('id = "%s",\n' % (self.id,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('analysistype', node)
        if value is not None and 'analysistype' not in already_processed:
            already_processed.append('analysistype')
            self.analysistype = value
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.append('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class default


class vector(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, i=None, planar=None, axi=None, j=None, default=None):
        self.i = _cast(int, i)
        self.planar = _cast(None, planar)
        self.axi = _cast(None, axi)
        self.j = _cast(int, j)
        if default is None:
            self.default = []
        else:
            self.default = default
    def factory(*args_, **kwargs_):
        if vector.subclass:
            return vector.subclass(*args_, **kwargs_)
        else:
            return vector(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_default(self): return self.default
    def set_default(self, default): self.default = default
    def add_default(self, value): self.default.append(value)
    def insert_default(self, index, value): self.default[index] = value
    def get_i(self): return self.i
    def set_i(self, i): self.i = i
    def get_planar(self): return self.planar
    def set_planar(self, planar): self.planar = planar
    def get_axi(self): return self.axi
    def set_axi(self, axi): self.axi = axi
    def get_j(self): return self.j
    def set_j(self, j): self.j = j
    def export(self, outfile, level, namespace_='', name_='vector', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='vector')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='vector'):
        if self.i is not None and 'i' not in already_processed:
            already_processed.append('i')
            outfile.write(' i="%s"' % self.gds_format_integer(self.i, input_name='i'))
        if self.planar is not None and 'planar' not in already_processed:
            already_processed.append('planar')
            outfile.write(' planar=%s' % (self.gds_format_string(quote_attrib(self.planar).encode(ExternalEncoding), input_name='planar'), ))
        if self.axi is not None and 'axi' not in already_processed:
            already_processed.append('axi')
            outfile.write(' axi=%s' % (self.gds_format_string(quote_attrib(self.axi).encode(ExternalEncoding), input_name='axi'), ))
        if self.j is not None and 'j' not in already_processed:
            already_processed.append('j')
            outfile.write(' j="%s"' % self.gds_format_integer(self.j, input_name='j'))
    def exportChildren(self, outfile, level, namespace_='', name_='vector', fromsubclass_=False):
        for default_ in self.default:
            default_.export(outfile, level, namespace_, name_='default')
    def hasContent_(self):
        if (
            self.default
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='vector'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.i is not None and 'i' not in already_processed:
            already_processed.append('i')
            showIndent(outfile, level)
            outfile.write('i = %d,\n' % (self.i,))
        if self.planar is not None and 'planar' not in already_processed:
            already_processed.append('planar')
            showIndent(outfile, level)
            outfile.write('planar = "%s",\n' % (self.planar,))
        if self.axi is not None and 'axi' not in already_processed:
            already_processed.append('axi')
            showIndent(outfile, level)
            outfile.write('axi = "%s",\n' % (self.axi,))
        if self.j is not None and 'j' not in already_processed:
            already_processed.append('j')
            showIndent(outfile, level)
            outfile.write('j = %d,\n' % (self.j,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('default=[\n')
        level += 1
        for default_ in self.default:
            showIndent(outfile, level)
            outfile.write('model_.default(\n')
            default_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('i', node)
        if value is not None and 'i' not in already_processed:
            already_processed.append('i')
            try:
                self.i = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('planar', node)
        if value is not None and 'planar' not in already_processed:
            already_processed.append('planar')
            self.planar = value
        value = find_attr_value_('axi', node)
        if value is not None and 'axi' not in already_processed:
            already_processed.append('axi')
            self.axi = value
        value = find_attr_value_('j', node)
        if value is not None and 'j' not in already_processed:
            already_processed.append('j')
            try:
                self.j = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'default':
            obj_ = default.factory()
            obj_.build(child_)
            self.default.append(obj_)
# end class vector


class quantity(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, timedep=None, unit_html=None, nonlin=None, name=None, default=None, shortname_latex=None, shortname_html=None, unit_latex=None, unit=None, shortname=None, id=None, condition=None):
        self.timedep = _cast(int, timedep)
        self.unit_html = _cast(None, unit_html)
        self.nonlin = _cast(int, nonlin)
        self.name = _cast(None, name)
        self.default = _cast(float, default)
        self.shortname_latex = _cast(None, shortname_latex)
        self.shortname_html = _cast(None, shortname_html)
        self.unit_latex = _cast(None, unit_latex)
        self.unit = _cast(None, unit)
        self.shortname = _cast(None, shortname)
        self.id = _cast(None, id)
        self.condition = _cast(None, condition)
        pass
    def factory(*args_, **kwargs_):
        if quantity.subclass:
            return quantity.subclass(*args_, **kwargs_)
        else:
            return quantity(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_timedep(self): return self.timedep
    def set_timedep(self, timedep): self.timedep = timedep
    def get_unit_html(self): return self.unit_html
    def set_unit_html(self, unit_html): self.unit_html = unit_html
    def get_nonlin(self): return self.nonlin
    def set_nonlin(self, nonlin): self.nonlin = nonlin
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_default(self): return self.default
    def set_default(self, default): self.default = default
    def get_shortname_latex(self): return self.shortname_latex
    def set_shortname_latex(self, shortname_latex): self.shortname_latex = shortname_latex
    def get_shortname_html(self): return self.shortname_html
    def set_shortname_html(self, shortname_html): self.shortname_html = shortname_html
    def get_unit_latex(self): return self.unit_latex
    def set_unit_latex(self, unit_latex): self.unit_latex = unit_latex
    def get_unit(self): return self.unit
    def set_unit(self, unit): self.unit = unit
    def get_shortname(self): return self.shortname
    def set_shortname(self, shortname): self.shortname = shortname
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_condition(self): return self.condition
    def set_condition(self, condition): self.condition = condition
    def export(self, outfile, level, namespace_='', name_='quantity', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='quantity')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='quantity'):
        if self.timedep is not None and 'timedep' not in already_processed:
            already_processed.append('timedep')
            outfile.write(' timedep="%s"' % self.gds_format_integer(self.timedep, input_name='timedep'))
        if self.unit_html is not None and 'unit_html' not in already_processed:
            already_processed.append('unit_html')
            outfile.write(' unit_html=%s' % (self.gds_format_string(quote_attrib(self.unit_html).encode(ExternalEncoding), input_name='unit_html'), ))
        if self.nonlin is not None and 'nonlin' not in already_processed:
            already_processed.append('nonlin')
            outfile.write(' nonlin="%s"' % self.gds_format_integer(self.nonlin, input_name='nonlin'))
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
        if self.default is not None and 'default' not in already_processed:
            already_processed.append('default')
            outfile.write(' default="%s"' % self.gds_format_float(self.default, input_name='default'))
        if self.shortname_latex is not None and 'shortname_latex' not in already_processed:
            already_processed.append('shortname_latex')
            outfile.write(' shortname_latex=%s' % (self.gds_format_string(quote_attrib(self.shortname_latex).encode(ExternalEncoding), input_name='shortname_latex'), ))
        if self.shortname_html is not None and 'shortname_html' not in already_processed:
            already_processed.append('shortname_html')
            outfile.write(' shortname_html=%s' % (self.gds_format_string(quote_attrib(self.shortname_html).encode(ExternalEncoding), input_name='shortname_html'), ))
        if self.unit_latex is not None and 'unit_latex' not in already_processed:
            already_processed.append('unit_latex')
            outfile.write(' unit_latex=%s' % (self.gds_format_string(quote_attrib(self.unit_latex).encode(ExternalEncoding), input_name='unit_latex'), ))
        if self.unit is not None and 'unit' not in already_processed:
            already_processed.append('unit')
            outfile.write(' unit=%s' % (self.gds_format_string(quote_attrib(self.unit).encode(ExternalEncoding), input_name='unit'), ))
        if self.shortname is not None and 'shortname' not in already_processed:
            already_processed.append('shortname')
            outfile.write(' shortname=%s' % (self.gds_format_string(quote_attrib(self.shortname).encode(ExternalEncoding), input_name='shortname'), ))
        if self.id is not None and 'id' not in already_processed:
            already_processed.append('id')
            outfile.write(' id=%s' % (quote_attrib(self.id), ))
        if self.condition is not None and 'condition' not in already_processed:
            already_processed.append('condition')
            outfile.write(' condition=%s' % (self.gds_format_string(quote_attrib(self.condition).encode(ExternalEncoding), input_name='condition'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='quantity', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='quantity'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.timedep is not None and 'timedep' not in already_processed:
            already_processed.append('timedep')
            showIndent(outfile, level)
            outfile.write('timedep = %d,\n' % (self.timedep,))
        if self.unit_html is not None and 'unit_html' not in already_processed:
            already_processed.append('unit_html')
            showIndent(outfile, level)
            outfile.write('unit_html = "%s",\n' % (self.unit_html,))
        if self.nonlin is not None and 'nonlin' not in already_processed:
            already_processed.append('nonlin')
            showIndent(outfile, level)
            outfile.write('nonlin = %d,\n' % (self.nonlin,))
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            showIndent(outfile, level)
            outfile.write('name = "%s",\n' % (self.name,))
        if self.default is not None and 'default' not in already_processed:
            already_processed.append('default')
            showIndent(outfile, level)
            outfile.write('default = %f,\n' % (self.default,))
        if self.shortname_latex is not None and 'shortname_latex' not in already_processed:
            already_processed.append('shortname_latex')
            showIndent(outfile, level)
            outfile.write('shortname_latex = "%s",\n' % (self.shortname_latex,))
        if self.shortname_html is not None and 'shortname_html' not in already_processed:
            already_processed.append('shortname_html')
            showIndent(outfile, level)
            outfile.write('shortname_html = "%s",\n' % (self.shortname_html,))
        if self.unit_latex is not None and 'unit_latex' not in already_processed:
            already_processed.append('unit_latex')
            showIndent(outfile, level)
            outfile.write('unit_latex = "%s",\n' % (self.unit_latex,))
        if self.unit is not None and 'unit' not in already_processed:
            already_processed.append('unit')
            showIndent(outfile, level)
            outfile.write('unit = "%s",\n' % (self.unit,))
        if self.shortname is not None and 'shortname' not in already_processed:
            already_processed.append('shortname')
            showIndent(outfile, level)
            outfile.write('shortname = "%s",\n' % (self.shortname,))
        if self.id is not None and 'id' not in already_processed:
            already_processed.append('id')
            showIndent(outfile, level)
            outfile.write('id = "%s",\n' % (self.id,))
        if self.condition is not None and 'condition' not in already_processed:
            already_processed.append('condition')
            showIndent(outfile, level)
            outfile.write('condition = "%s",\n' % (self.condition,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('timedep', node)
        if value is not None and 'timedep' not in already_processed:
            already_processed.append('timedep')
            try:
                self.timedep = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('unit_html', node)
        if value is not None and 'unit_html' not in already_processed:
            already_processed.append('unit_html')
            self.unit_html = value
        value = find_attr_value_('nonlin', node)
        if value is not None and 'nonlin' not in already_processed:
            already_processed.append('nonlin')
            try:
                self.nonlin = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.append('name')
            self.name = value
        value = find_attr_value_('default', node)
        if value is not None and 'default' not in already_processed:
            already_processed.append('default')
            try:
                self.default = float(value)
            except ValueError, exp:
                raise ValueError('Bad float/double attribute (default): %s' % exp)
        value = find_attr_value_('shortname_latex', node)
        if value is not None and 'shortname_latex' not in already_processed:
            already_processed.append('shortname_latex')
            self.shortname_latex = value
        value = find_attr_value_('shortname_html', node)
        if value is not None and 'shortname_html' not in already_processed:
            already_processed.append('shortname_html')
            self.shortname_html = value
        value = find_attr_value_('unit_latex', node)
        if value is not None and 'unit_latex' not in already_processed:
            already_processed.append('unit_latex')
            self.unit_latex = value
        value = find_attr_value_('unit', node)
        if value is not None and 'unit' not in already_processed:
            already_processed.append('unit')
            self.unit = value
        value = find_attr_value_('shortname', node)
        if value is not None and 'shortname' not in already_processed:
            already_processed.append('shortname')
            self.shortname = value
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.append('id')
            self.id = value
        value = find_attr_value_('condition', node)
        if value is not None and 'condition' not in already_processed:
            already_processed.append('condition')
            self.condition = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class quantity


class weakforms(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, weakform=None):
        if weakform is None:
            self.weakform = []
        else:
            self.weakform = weakform
    def factory(*args_, **kwargs_):
        if weakforms.subclass:
            return weakforms.subclass(*args_, **kwargs_)
        else:
            return weakforms(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_weakform(self): return self.weakform
    def set_weakform(self, weakform): self.weakform = weakform
    def add_weakform(self, value): self.weakform.append(value)
    def insert_weakform(self, index, value): self.weakform[index] = value
    def export(self, outfile, level, namespace_='', name_='weakforms', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='weakforms')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='weakforms'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='weakforms', fromsubclass_=False):
        for weakform_ in self.weakform:
            weakform_.export(outfile, level, namespace_, name_='weakform')
    def hasContent_(self):
        if (
            self.weakform
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='weakforms'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('weakform=[\n')
        level += 1
        for weakform_ in self.weakform:
            showIndent(outfile, level)
            outfile.write('model_.weakform(\n')
            weakform_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'weakform':
            obj_ = weakform.factory()
            obj_.build(child_)
            self.weakform.append(obj_)
# end class weakforms


class weakform(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, default=None, analysistype=None, boundary=None, quantity=None, matrix=None, vector=None):
        self.default = _cast(None, default)
        self.analysistype = _cast(None, analysistype)
        if boundary is None:
            self.boundary = []
        else:
            self.boundary = boundary
        if quantity is None:
            self.quantity = []
        else:
            self.quantity = quantity
        if matrix is None:
            self.matrix = []
        else:
            self.matrix = matrix
        if vector is None:
            self.vector = []
        else:
            self.vector = vector
    def factory(*args_, **kwargs_):
        if weakform.subclass:
            return weakform.subclass(*args_, **kwargs_)
        else:
            return weakform(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_boundary(self): return self.boundary
    def set_boundary(self, boundary): self.boundary = boundary
    def add_boundary(self, value): self.boundary.append(value)
    def insert_boundary(self, index, value): self.boundary[index] = value
    def get_quantity(self): return self.quantity
    def set_quantity(self, quantity): self.quantity = quantity
    def add_quantity(self, value): self.quantity.append(value)
    def insert_quantity(self, index, value): self.quantity[index] = value
    def get_matrix(self): return self.matrix
    def set_matrix(self, matrix): self.matrix = matrix
    def add_matrix(self, value): self.matrix.append(value)
    def insert_matrix(self, index, value): self.matrix[index] = value
    def get_vector(self): return self.vector
    def set_vector(self, vector): self.vector = vector
    def add_vector(self, value): self.vector.append(value)
    def insert_vector(self, index, value): self.vector[index] = value
    def get_default(self): return self.default
    def set_default(self, default): self.default = default
    def get_analysistype(self): return self.analysistype
    def set_analysistype(self, analysistype): self.analysistype = analysistype
    def export(self, outfile, level, namespace_='', name_='weakform', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='weakform')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='weakform'):
        if self.default is not None and 'default' not in already_processed:
            already_processed.append('default')
            outfile.write(' default=%s' % (quote_attrib(self.default), ))
        if self.analysistype is not None and 'analysistype' not in already_processed:
            already_processed.append('analysistype')
            outfile.write(' analysistype=%s' % (quote_attrib(self.analysistype), ))
    def exportChildren(self, outfile, level, namespace_='', name_='weakform', fromsubclass_=False):
        for boundary_ in self.boundary:
            boundary_.export(outfile, level, namespace_, name_='boundary')
        for quantity_ in self.quantity:
            quantity_.export(outfile, level, namespace_, name_='quantity')
        for matrix_ in self.matrix:
            matrix_.export(outfile, level, namespace_, name_='matrix')
        for vector_ in self.vector:
            vector_.export(outfile, level, namespace_, name_='vector')
    def hasContent_(self):
        if (
            self.boundary or
            self.quantity or
            self.matrix or
            self.vector
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='weakform'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.default is not None and 'default' not in already_processed:
            already_processed.append('default')
            showIndent(outfile, level)
            outfile.write('default = "%s",\n' % (self.default,))
        if self.analysistype is not None and 'analysistype' not in already_processed:
            already_processed.append('analysistype')
            showIndent(outfile, level)
            outfile.write('analysistype = "%s",\n' % (self.analysistype,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('boundary=[\n')
        level += 1
        for boundary_ in self.boundary:
            showIndent(outfile, level)
            outfile.write('model_.boundary(\n')
            boundary_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('quantity=[\n')
        level += 1
        for quantity_ in self.quantity:
            showIndent(outfile, level)
            outfile.write('model_.quantity(\n')
            quantity_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('matrix=[\n')
        level += 1
        for matrix_ in self.matrix:
            showIndent(outfile, level)
            outfile.write('model_.matrix(\n')
            matrix_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('vector=[\n')
        level += 1
        for vector_ in self.vector:
            showIndent(outfile, level)
            outfile.write('model_.vector(\n')
            vector_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('default', node)
        if value is not None and 'default' not in already_processed:
            already_processed.append('default')
            self.default = value
        value = find_attr_value_('analysistype', node)
        if value is not None and 'analysistype' not in already_processed:
            already_processed.append('analysistype')
            self.analysistype = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'boundary':
            obj_ = boundary.factory()
            obj_.build(child_)
            self.boundary.append(obj_)
        elif nodeName_ == 'quantity':
            obj_ = quantity.factory()
            obj_.build(child_)
            self.quantity.append(obj_)
        elif nodeName_ == 'matrix':
            obj_ = matrix.factory()
            obj_.build(child_)
            self.matrix.append(obj_)
        elif nodeName_ == 'vector':
            obj_ = vector.factory()
            obj_.build(child_)
            self.vector.append(obj_)
# end class weakform


class boundary(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, id=None, name=None, quantity=None, matrix=None, vector=None, essential=None):
        self.id = _cast(None, id)
        self.name = _cast(None, name)
        if quantity is None:
            self.quantity = []
        else:
            self.quantity = quantity
        if matrix is None:
            self.matrix = []
        else:
            self.matrix = matrix
        if vector is None:
            self.vector = []
        else:
            self.vector = vector
        if essential is None:
            self.essential = []
        else:
            self.essential = essential
    def factory(*args_, **kwargs_):
        if boundary.subclass:
            return boundary.subclass(*args_, **kwargs_)
        else:
            return boundary(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_quantity(self): return self.quantity
    def set_quantity(self, quantity): self.quantity = quantity
    def add_quantity(self, value): self.quantity.append(value)
    def insert_quantity(self, index, value): self.quantity[index] = value
    def get_matrix(self): return self.matrix
    def set_matrix(self, matrix): self.matrix = matrix
    def add_matrix(self, value): self.matrix.append(value)
    def insert_matrix(self, index, value): self.matrix[index] = value
    def get_vector(self): return self.vector
    def set_vector(self, vector): self.vector = vector
    def add_vector(self, value): self.vector.append(value)
    def insert_vector(self, index, value): self.vector[index] = value
    def get_essential(self): return self.essential
    def set_essential(self, essential): self.essential = essential
    def add_essential(self, value): self.essential.append(value)
    def insert_essential(self, index, value): self.essential[index] = value
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def export(self, outfile, level, namespace_='', name_='boundary', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='boundary')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='boundary'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.append('id')
            outfile.write(' id=%s' % (quote_attrib(self.id), ))
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='boundary', fromsubclass_=False):
        for quantity_ in self.quantity:
            quantity_.export(outfile, level, namespace_, name_='quantity')
        for matrix_ in self.matrix:
            matrix_.export(outfile, level, namespace_, name_='matrix')
        for vector_ in self.vector:
            vector_.export(outfile, level, namespace_, name_='vector')
        for essential_ in self.essential:
            essential_.export(outfile, level, namespace_, name_='essential')
    def hasContent_(self):
        if (
            self.quantity or
            self.matrix or
            self.vector or
            self.essential
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='boundary'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.id is not None and 'id' not in already_processed:
            already_processed.append('id')
            showIndent(outfile, level)
            outfile.write('id = "%s",\n' % (self.id,))
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            showIndent(outfile, level)
            outfile.write('name = "%s",\n' % (self.name,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('quantity=[\n')
        level += 1
        for quantity_ in self.quantity:
            showIndent(outfile, level)
            outfile.write('model_.quantity(\n')
            quantity_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('matrix=[\n')
        level += 1
        for matrix_ in self.matrix:
            showIndent(outfile, level)
            outfile.write('model_.matrix(\n')
            matrix_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('vector=[\n')
        level += 1
        for vector_ in self.vector:
            showIndent(outfile, level)
            outfile.write('model_.vector(\n')
            vector_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('essential=[\n')
        level += 1
        for essential_ in self.essential:
            showIndent(outfile, level)
            outfile.write('model_.essential(\n')
            essential_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.append('id')
            self.id = value
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.append('name')
            self.name = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'quantity':
            obj_ = quantity.factory()
            obj_.build(child_)
            self.quantity.append(obj_)
        elif nodeName_ == 'matrix':
            obj_ = matrix.factory()
            obj_.build(child_)
            self.matrix.append(obj_)
        elif nodeName_ == 'vector':
            obj_ = vector.factory()
            obj_.build(child_)
            self.vector.append(obj_)
        elif nodeName_ == 'essential':
            obj_ = essential.factory()
            obj_.build(child_)
            self.essential.append(obj_)
# end class boundary


class essential(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, i=None, planar=None, axi=None):
        self.i = _cast(int, i)
        self.planar = _cast(None, planar)
        self.axi = _cast(None, axi)
        pass
    def factory(*args_, **kwargs_):
        if essential.subclass:
            return essential.subclass(*args_, **kwargs_)
        else:
            return essential(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_i(self): return self.i
    def set_i(self, i): self.i = i
    def get_planar(self): return self.planar
    def set_planar(self, planar): self.planar = planar
    def get_axi(self): return self.axi
    def set_axi(self, axi): self.axi = axi
    def export(self, outfile, level, namespace_='', name_='essential', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='essential')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='essential'):
        if self.i is not None and 'i' not in already_processed:
            already_processed.append('i')
            outfile.write(' i="%s"' % self.gds_format_integer(self.i, input_name='i'))
        if self.planar is not None and 'planar' not in already_processed:
            already_processed.append('planar')
            outfile.write(' planar=%s' % (quote_attrib(self.planar), ))
        if self.axi is not None and 'axi' not in already_processed:
            already_processed.append('axi')
            outfile.write(' axi=%s' % (quote_attrib(self.axi), ))
    def exportChildren(self, outfile, level, namespace_='', name_='essential', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='essential'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.i is not None and 'i' not in already_processed:
            already_processed.append('i')
            showIndent(outfile, level)
            outfile.write('i = %d,\n' % (self.i,))
        if self.planar is not None and 'planar' not in already_processed:
            already_processed.append('planar')
            showIndent(outfile, level)
            outfile.write('planar = "%s",\n' % (self.planar,))
        if self.axi is not None and 'axi' not in already_processed:
            already_processed.append('axi')
            showIndent(outfile, level)
            outfile.write('axi = "%s",\n' % (self.axi,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('i', node)
        if value is not None and 'i' not in already_processed:
            already_processed.append('i')
            try:
                self.i = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('planar', node)
        if value is not None and 'planar' not in already_processed:
            already_processed.append('planar')
            self.planar = value
        value = find_attr_value_('axi', node)
        if value is not None and 'axi' not in already_processed:
            already_processed.append('axi')
            self.axi = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class essential


class group(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, name=None, quantity=None):
        self.name = _cast(None, name)
        if quantity is None:
            self.quantity = []
        else:
            self.quantity = quantity
    def factory(*args_, **kwargs_):
        if group.subclass:
            return group.subclass(*args_, **kwargs_)
        else:
            return group(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_quantity(self): return self.quantity
    def set_quantity(self, quantity): self.quantity = quantity
    def add_quantity(self, value): self.quantity.append(value)
    def insert_quantity(self, index, value): self.quantity[index] = value
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def export(self, outfile, level, namespace_='', name_='group', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='group')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='group'):
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='group', fromsubclass_=False):
        for quantity_ in self.quantity:
            quantity_.export(outfile, level, namespace_, name_='quantity')
    def hasContent_(self):
        if (
            self.quantity
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='group'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            showIndent(outfile, level)
            outfile.write('name = "%s",\n' % (self.name,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('quantity=[\n')
        level += 1
        for quantity_ in self.quantity:
            showIndent(outfile, level)
            outfile.write('model_.quantity(\n')
            quantity_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.append('name')
            self.name = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'quantity':
            obj_ = quantity.factory()
            obj_.build(child_)
            self.quantity.append(obj_)
# end class group


class matrix(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, i=None, symmetric=None, planar=None, axi=None, j=None):
        self.i = _cast(int, i)
        self.symmetric = _cast(int, symmetric)
        self.planar = _cast(None, planar)
        self.axi = _cast(None, axi)
        self.j = _cast(int, j)
        pass
    def factory(*args_, **kwargs_):
        if matrix.subclass:
            return matrix.subclass(*args_, **kwargs_)
        else:
            return matrix(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_i(self): return self.i
    def set_i(self, i): self.i = i
    def get_symmetric(self): return self.symmetric
    def set_symmetric(self, symmetric): self.symmetric = symmetric
    def get_planar(self): return self.planar
    def set_planar(self, planar): self.planar = planar
    def get_axi(self): return self.axi
    def set_axi(self, axi): self.axi = axi
    def get_j(self): return self.j
    def set_j(self, j): self.j = j
    def export(self, outfile, level, namespace_='', name_='matrix', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='matrix')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='matrix'):
        if self.i is not None and 'i' not in already_processed:
            already_processed.append('i')
            outfile.write(' i="%s"' % self.gds_format_integer(self.i, input_name='i'))
        if self.symmetric is not None and 'symmetric' not in already_processed:
            already_processed.append('symmetric')
            outfile.write(' symmetric="%s"' % self.gds_format_integer(self.symmetric, input_name='symmetric'))
        if self.planar is not None and 'planar' not in already_processed:
            already_processed.append('planar')
            outfile.write(' planar=%s' % (self.gds_format_string(quote_attrib(self.planar).encode(ExternalEncoding), input_name='planar'), ))
        if self.axi is not None and 'axi' not in already_processed:
            already_processed.append('axi')
            outfile.write(' axi=%s' % (self.gds_format_string(quote_attrib(self.axi).encode(ExternalEncoding), input_name='axi'), ))
        if self.j is not None and 'j' not in already_processed:
            already_processed.append('j')
            outfile.write(' j="%s"' % self.gds_format_integer(self.j, input_name='j'))
    def exportChildren(self, outfile, level, namespace_='', name_='matrix', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='matrix'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.i is not None and 'i' not in already_processed:
            already_processed.append('i')
            showIndent(outfile, level)
            outfile.write('i = %d,\n' % (self.i,))
        if self.symmetric is not None and 'symmetric' not in already_processed:
            already_processed.append('symmetric')
            showIndent(outfile, level)
            outfile.write('symmetric = %d,\n' % (self.symmetric,))
        if self.planar is not None and 'planar' not in already_processed:
            already_processed.append('planar')
            showIndent(outfile, level)
            outfile.write('planar = "%s",\n' % (self.planar,))
        if self.axi is not None and 'axi' not in already_processed:
            already_processed.append('axi')
            showIndent(outfile, level)
            outfile.write('axi = "%s",\n' % (self.axi,))
        if self.j is not None and 'j' not in already_processed:
            already_processed.append('j')
            showIndent(outfile, level)
            outfile.write('j = %d,\n' % (self.j,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('i', node)
        if value is not None and 'i' not in already_processed:
            already_processed.append('i')
            try:
                self.i = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('symmetric', node)
        if value is not None and 'symmetric' not in already_processed:
            already_processed.append('symmetric')
            try:
                self.symmetric = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('planar', node)
        if value is not None and 'planar' not in already_processed:
            already_processed.append('planar')
            self.planar = value
        value = find_attr_value_('axi', node)
        if value is not None and 'axi' not in already_processed:
            already_processed.append('axi')
            self.axi = value
        value = find_attr_value_('j', node)
        if value is not None and 'j' not in already_processed:
            already_processed.append('j')
            try:
                self.j = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class matrix


USAGE_TEXT = """
Usage: python <Parser>.py [ -s ] <in_xml_file>
"""

def usage():
    print USAGE_TEXT
    sys.exit(1)


def get_root_tag(node):
    tag = Tag_pattern_.match(node.tag).groups()[-1]
    rootClass = globals().get(tag)
    return tag, rootClass


def parse(inFileName):
    doc = parsexml_(inFileName)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'module'
        rootClass = module
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    #sys.stdout.write('<?xml version="1.0" ?>\n')
    #rootObj.export(sys.stdout, 0, name_=rootTag, 
    #    namespacedef_='')
    return rootObj


def parseString(inString):
    from StringIO import StringIO
    doc = parsexml_(StringIO(inString))
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'module'
        rootClass = module
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    sys.stdout.write('<?xml version="1.0" ?>\n')
    rootObj.export(sys.stdout, 0, name_="module",
        namespacedef_='')
    return rootObj


def parseLiteral(inFileName):
    doc = parsexml_(inFileName)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'module'
        rootClass = module
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    sys.stdout.write('#from module import *\n\n')
    sys.stdout.write('import module as model_\n\n')
    sys.stdout.write('rootObj = model_.rootTag(\n')
    rootObj.exportLiteral(sys.stdout, 0, name_=rootTag)
    sys.stdout.write(')\n')
    return rootObj


def main():
    args = sys.argv[1:]
    if len(args) == 1:
        parse(args[0])
    else:
        usage()


if __name__ == '__main__':
    #import pdb; pdb.set_trace()
    main()


__all__ = [
    "analyses",
    "analysis",
    "boundary",
    "constant",
    "constants",
    "default",
    "essential",
    "expression",
    "general",
    "group",
    "localvariable",
    "localvariables",
    "macro",
    "macros",
    "matrix",
    "module",
    "postprocessor",
    "preprocessor",
    "quantity",
    "scalar",
    "surface",
    "surfaceintegral",
    "surfaceintegrals",
    "vector",
    "view",
    "volume",
    "volumeintegral",
    "volumeintegrals",
    "weakform",
    "weakforms"
    ]
